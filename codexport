#!/usr/bin/env python3
"""Export Codex session JSONL logs to Markdown."""

from __future__ import annotations

import argparse
import json
import sys
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Any


def _safe_json(obj: Any) -> str:
    try:
        return json.dumps(obj, ensure_ascii=False, indent=2)
    except Exception:
        return str(obj)


def _extract_text_from_content(content: Any) -> str:
    if not isinstance(content, list):
        return ""

    parts: list[str] = []
    for item in content:
        if not isinstance(item, dict):
            continue

        text = item.get("text")
        if isinstance(text, str):
            parts.append(text)
            continue

        for key in ("output_text", "input_text"):
            value = item.get(key)
            if isinstance(value, str):
                parts.append(value)
                break

    return "\n\n".join(part for part in parts if part.strip())


def _truncate(text: str, max_chars: int) -> str:
    if len(text) <= max_chars:
        return text
    return f"{text[:max_chars]}\n\n... (truncated {len(text) - max_chars} chars)"


def _emit_message(
    lines: list[str],
    idx: int,
    timestamp: str,
    payload: dict[str, Any],
    include_timestamp: bool,
) -> None:
    role = payload.get("role", "unknown")
    phase = payload.get("phase")
    title = f"## {idx}. {role}"
    if phase:
        title += f" ({phase})"
    lines.append(title)
    lines.append("")
    if include_timestamp:
        lines.append(f"- `timestamp`: `{timestamp}`")
        lines.append("")
    text = _extract_text_from_content(payload.get("content"))
    if text:
        lines.append(text)
    else:
        lines.append("_No textual content_")
    lines.append("")


def _emit_reasoning(
    lines: list[str],
    idx: int,
    timestamp: str,
    payload: dict[str, Any],
    include_timestamp: bool,
) -> None:
    summaries = payload.get("summary")
    summary_texts: list[str] = []
    if isinstance(summaries, list):
        for item in summaries:
            if isinstance(item, dict):
                t = item.get("text")
                if isinstance(t, str) and t.strip():
                    summary_texts.append(t.strip())
    text = "\n".join(summary_texts).strip() or "_No public reasoning summary_"

    lines.append(f"## {idx}. reasoning")
    lines.append("")
    if include_timestamp:
        lines.append(f"- `timestamp`: `{timestamp}`")
        lines.append("")
    lines.append(text)
    lines.append("")


def _emit_function_call(
    lines: list[str],
    idx: int,
    timestamp: str,
    payload: dict[str, Any],
    include_timestamp: bool,
) -> None:
    name = payload.get("name", "unknown")
    call_id = payload.get("call_id", "unknown")
    arguments = payload.get("arguments", "")

    lines.append(f"## {idx}. tool_call `{name}`")
    lines.append("")
    if include_timestamp:
        lines.append(f"- `timestamp`: `{timestamp}`")
    lines.append(f"- `call_id`: `{call_id}`")
    lines.append("")
    lines.append("```json")
    if isinstance(arguments, str):
        lines.append(arguments)
    else:
        lines.append(_safe_json(arguments))
    lines.append("```")
    lines.append("")


def _emit_function_call_output(
    lines: list[str],
    idx: int,
    timestamp: str,
    payload: dict[str, Any],
    max_tool_output_chars: int,
    include_timestamp: bool,
) -> None:
    call_id = payload.get("call_id", "unknown")
    output = payload.get("output", "")
    output_str = output if isinstance(output, str) else _safe_json(output)
    output_str = _truncate(output_str, max_tool_output_chars)

    lines.append(f"## {idx}. tool_output")
    lines.append("")
    if include_timestamp:
        lines.append(f"- `timestamp`: `{timestamp}`")
    lines.append(f"- `call_id`: `{call_id}`")
    lines.append("")
    lines.append("```text")
    lines.append(output_str)
    lines.append("```")
    lines.append("")


def export_session(
    input_path: Path,
    include_all: bool,
    max_tool_output_chars: int,
) -> str:
    lines: list[str] = []
    session_meta: dict[str, Any] | None = None
    section_index = 1

    with input_path.open("r", encoding="utf-8") as f:
        for raw in f:
            raw = raw.strip()
            if not raw:
                continue

            try:
                row = json.loads(raw)
            except json.JSONDecodeError:
                continue

            row_type = row.get("type")
            timestamp = str(row.get("timestamp", "unknown"))
            payload = row.get("payload")
            if not isinstance(payload, dict):
                payload = {}

            if row_type == "session_meta":
                session_meta = payload
                continue

            if row_type == "response_item":
                item_type = payload.get("type")
                if item_type == "message":
                    role = payload.get("role", "unknown")
                    phase = payload.get("phase")
                    text = _extract_text_from_content(payload.get("content"))
                    if include_all or _should_include_default_chat_message(
                        role=role, phase=phase, text=text
                    ):
                        _emit_message(
                            lines,
                            section_index,
                            timestamp,
                            payload,
                            include_timestamp=include_all,
                        )
                        section_index += 1
                elif item_type == "reasoning":
                    if include_all:
                        _emit_reasoning(
                            lines,
                            section_index,
                            timestamp,
                            payload,
                            include_timestamp=True,
                        )
                        section_index += 1
                elif item_type == "function_call":
                    if include_all:
                        _emit_function_call(
                            lines,
                            section_index,
                            timestamp,
                            payload,
                            include_timestamp=True,
                        )
                        section_index += 1
                elif item_type == "function_call_output":
                    if include_all:
                        _emit_function_call_output(
                            lines,
                            section_index,
                            timestamp,
                            payload,
                            max_tool_output_chars=max_tool_output_chars,
                            include_timestamp=True,
                        )
                        section_index += 1
                continue

            if row_type == "event_msg" and include_all:
                event_type = payload.get("type", "unknown")
                lines.append(f"## {section_index}. event `{event_type}`")
                lines.append("")
                lines.append(f"- `timestamp`: `{timestamp}`")
                lines.append("")
                lines.append("```json")
                lines.append(_safe_json(payload))
                lines.append("```")
                lines.append("")
                section_index += 1
                continue

            if row_type == "turn_context" and include_all:
                lines.append(f"## {section_index}. turn_context")
                lines.append("")
                lines.append(f"- `timestamp`: `{timestamp}`")
                lines.append("")
                lines.append("```json")
                lines.append(_safe_json(payload))
                lines.append("```")
                lines.append("")
                section_index += 1

    out: list[str] = []
    out.append(f"# Codex Session Export: `{input_path.name}`")
    out.append("")

    if session_meta:
        out.append("## Session Metadata")
        out.append("")
        for key in (
            "id",
            "timestamp",
            "cwd",
            "originator",
            "cli_version",
            "source",
            "model_provider",
        ):
            if key == "timestamp" and not include_all:
                continue
            if key in session_meta:
                out.append(f"- `{key}`: `{session_meta[key]}`")
        out.append("")

    out.append("## Timeline")
    out.append("")
    if lines:
        out.extend(lines)
    else:
        out.append("_No exportable timeline items found_")
        out.append("")

    return "\n".join(out)


def _should_include_default_chat_message(role: Any, phase: Any, text: str) -> bool:
    role_str = str(role)
    phase_str = str(phase) if phase is not None else ""

    if role_str in {"developer", "system"}:
        return False
    if role_str == "assistant" and phase_str == "commentary":
        return False

    lowered = text.lower()
    setup_markers = (
        "<instructions>",
        "</instructions>",
        "<environment_context>",
        "</environment_context>",
        "<permissions instructions>",
        "</permissions instructions>",
        "<collaboration_mode>",
        "</collaboration_mode>",
        "# agents.md instructions",
    )
    if any(marker in lowered for marker in setup_markers):
        return False

    return bool(text.strip())


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description=__doc__)
    p.add_argument(
        "input",
        type=Path,
        nargs="?",
        help="Path to Codex session JSONL file. If omitted, an interactive selector is used.",
    )
    p.add_argument(
        "-o",
        "--output",
        type=Path,
        default=None,
        help="Output Markdown path. Defaults to <input>.md",
    )
    p.add_argument(
        "--all",
        action="store_true",
        help="Include all records (reasoning, tool calls/outputs, events, turn contexts).",
    )
    p.add_argument(
        "--max-tool-output-chars",
        type=int,
        default=4000,
        help="Max chars for each function_call_output block before truncation.",
    )
    p.add_argument(
        "--session-dir",
        type=Path,
        default=Path.home() / ".codex" / "sessions",
        help="Directory containing session JSONL files used by the selector.",
    )
    return p.parse_args()


def _find_session_files(session_dir: Path) -> list[Path]:
    files: list[Path] = []
    if not session_dir.exists():
        return files
    for path in session_dir.rglob("*.jsonl"):
        if not path.is_file():
            continue
        files.append(path)
    files.sort(key=lambda p: p.stat().st_mtime, reverse=True)
    return files


@dataclass
class SessionSummary:
    path: Path
    created_at: datetime | None
    updated_at: datetime | None
    cwd: str | None
    branch: str | None
    first_user_prompt: str | None


def _parse_timestamp(value: Any) -> datetime | None:
    if not isinstance(value, str):
        return None
    text = value.strip()
    if not text:
        return None
    if text.endswith("Z"):
        text = text[:-1] + "+00:00"
    try:
        dt = datetime.fromisoformat(text)
    except ValueError:
        return None
    if dt.tzinfo is None:
        return dt.replace(tzinfo=timezone.utc)
    return dt


def _format_timestamp(value: datetime | None) -> str:
    if value is None:
        return "unknown"
    return value.astimezone().strftime("%Y-%m-%d %H:%M:%S %Z")


def _summarize_prompt(text: str, max_chars: int = 110) -> str:
    single_line = " ".join(text.split())
    if len(single_line) <= max_chars:
        return single_line
    return single_line[: max_chars - 3].rstrip() + "..."


def _read_session_summary(path: Path) -> SessionSummary:
    created_at: datetime | None = None
    updated_at: datetime | None = None
    cwd: str | None = None
    branch: str | None = None
    first_user_prompt: str | None = None

    try:
        with path.open("r", encoding="utf-8") as f:
            for raw in f:
                raw = raw.strip()
                if not raw:
                    continue

                try:
                    row = json.loads(raw)
                except json.JSONDecodeError:
                    continue

                row_timestamp = _parse_timestamp(row.get("timestamp"))
                if row_timestamp is not None:
                    if created_at is None or row_timestamp < created_at:
                        created_at = row_timestamp
                    if updated_at is None or row_timestamp > updated_at:
                        updated_at = row_timestamp

                row_type = row.get("type")
                payload = row.get("payload")
                if not isinstance(payload, dict):
                    continue

                if row_type == "session_meta":
                    meta_timestamp = _parse_timestamp(payload.get("timestamp"))
                    if meta_timestamp is not None and (
                        created_at is None or meta_timestamp < created_at
                    ):
                        created_at = meta_timestamp

                    cwd_value = payload.get("cwd")
                    if isinstance(cwd_value, str) and cwd_value.strip():
                        cwd = cwd_value.strip()

                    git_info = payload.get("git")
                    if isinstance(git_info, dict):
                        value = git_info.get("branch")
                        if isinstance(value, str) and value.strip():
                            branch = value.strip()

                if row_type == "turn_context" and cwd is None:
                    cwd_value = payload.get("cwd")
                    if isinstance(cwd_value, str) and cwd_value.strip():
                        cwd = cwd_value.strip()

                if first_user_prompt is None and row_type == "response_item":
                    if payload.get("type") != "message":
                        continue
                    role = payload.get("role", "unknown")
                    phase = payload.get("phase")
                    text = _extract_text_from_content(payload.get("content"))
                    if role == "user" and _should_include_default_chat_message(
                        role=role,
                        phase=phase,
                        text=text,
                    ):
                        first_user_prompt = _summarize_prompt(text)
    except OSError:
        pass

    if created_at is None or updated_at is None:
        stat = path.stat()
        mtime = datetime.fromtimestamp(stat.st_mtime, tz=timezone.utc)
        if created_at is None:
            created_at = mtime
        if updated_at is None:
            updated_at = mtime

    return SessionSummary(
        path=path,
        created_at=created_at,
        updated_at=updated_at,
        cwd=cwd,
        branch=branch,
        first_user_prompt=first_user_prompt,
    )


def _format_choice(path: Path, session_dir: Path, summary: SessionSummary) -> str:
    try:
        rel = path.relative_to(session_dir)
        label = str(rel)
    except ValueError:
        label = str(path)
    created = _format_timestamp(summary.created_at)
    updated = _format_timestamp(summary.updated_at)
    cwd = summary.cwd or "-"
    branch = summary.branch or "-"
    prompt = summary.first_user_prompt or "-"
    return (
        f"{label}\n"
        f"    created: {created} | updated: {updated} | cwd: {cwd} | branch: {branch}\n"
        f"    prompt: {prompt}"
    )


def _select_session_path(session_dir: Path) -> Path:
    session_files = _find_session_files(session_dir)
    if not session_files:
        raise SystemExit(f"No session files found under: {session_dir}")

    if not sys.stdin.isatty():
        # In non-interactive contexts, default to the newest session file.
        chosen = session_files[0]
        print(f"No input provided; using latest session: {chosen}", file=sys.stderr)
        return chosen

    shown = session_files[:30]
    summaries = [_read_session_summary(path) for path in shown]
    print(f"Select a session file from: {session_dir}")
    for idx, (path, summary) in enumerate(zip(shown, summaries), start=1):
        print(f"{idx:2d}. {_format_choice(path, session_dir, summary)}")
    if len(session_files) > len(shown):
        print(f"... and {len(session_files) - len(shown)} more (showing newest 30)")

    while True:
        raw = input(f"Enter selection [1-{len(shown)}] (default 1, q to cancel): ").strip()
        if not raw:
            return shown[0]
        if raw.lower() in {"q", "quit", "exit"}:
            raise SystemExit("Session selection cancelled.")
        if raw.isdigit():
            selected = int(raw)
            if 1 <= selected <= len(shown):
                return shown[selected - 1]
        print("Invalid selection. Please enter a valid number.")


def _select_output_path(default_output: Path) -> Path:
    while True:
        try:
            raw = input(f"Output file path (default: {default_output}): ").strip()
        except EOFError:
            return default_output
        if not raw:
            return default_output

        candidate = Path(raw).expanduser()
        if candidate.exists() and candidate.is_dir():
            print("Output path is a directory. Please enter a file path.")
            continue
        return candidate


def main() -> int:
    args = parse_args()
    input_path: Path | None = args.input
    session_dir = args.session_dir.expanduser()
    used_interactive_selector = input_path is None and sys.stdin.isatty()
    if input_path is None:
        input_path = _select_session_path(session_dir)
    else:
        input_path = input_path.expanduser()
    if not input_path.exists():
        raise SystemExit(f"Input file not found: {input_path}")
    if not input_path.is_file():
        raise SystemExit(f"Input path is not a file: {input_path}")

    default_output = input_path.with_suffix(input_path.suffix + ".md")
    if args.output:
        output_path = args.output.expanduser()
    elif used_interactive_selector:
        output_path = _select_output_path(default_output)
    else:
        output_path = default_output
    md = export_session(
        input_path=input_path,
        include_all=args.all,
        max_tool_output_chars=args.max_tool_output_chars,
    )
    output_path.write_text(md, encoding="utf-8")
    print(f"Wrote {output_path}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
